<?xml version="1.0" encoding="utf-8"?>
<mcd>
  <MMLdefinition id="cds_set" cdrole="application" arity="nary" container="yes">
    <name>set</name>
    <description>
      <p>The set element is the container element that constructs a set of elements.  They
      may be explicitly listed, or defined by expressions or functions evaluated over a
      domain of application.  The domain of application may be given explicitly, or
      provided by means of one of the shortcut notations.</p>
    </description>
    <discussion>
      <p><ednote><name>MiKo</name>
      <edtext>Take the <el>list</el> and <el>set</el> parts of the discussion apart and
      make the <el>MMLdefinition</el>s selfcontained, maybe move some of the discussion
      into the CD description</edtext>
      </ednote>

      The <el>set</el> element is the container element that constructs a set of
      elements. The elements of a set can be defined either by explicitly listing the
      elements, or by evaluating a function over a domain of application as described in
      <specref ref="contm_qualifiers"/>.</p>

      <p>The <att>type</att> attribute indicates type of the set. Predefined values:
      <attval>normal</attval>, <attval>multiset</attval>.  <attval>multiset</attval>
      indicates that repetitions are allowed. The default value is
      <attval>normal</attval>.</p>

      <issue role="open" id="type_on_set">
	<head>Keep <att>type</att> attribute on <el>set</el>?</head>
	<p>It seems very awkward to keep this, it would probably be better to have an
	<code>multiset</code> content dictionary as OpenMath does.</p>
      </issue>

      <p>The child elements of a possibly empty <el>list</el> element are the actual
      components of an ordered <emph>list</emph>. For example, an ordered list of the
      three symbols <var>a</var>, <var>b</var>, and <var>c</var> is encoded as

      <eg role="mathml"><![CDATA[<list><ci>a</ci><ci>b</ci><ci>c</ci></list>]]></eg>
	
      Sets and lists can also be constructed by evaluating a function over a domain of
      application, each evaluation corresponding to a term of the set or list.  In the
      most general form a domain is explicitly specified by a <el>domainofapplication</el>
      element together with optional <el>bvar</el> elements.  Qualifications involving a
      <el>domainofapplication</el> element can be abbreviated in several ways as described
      in <specref ref="contm_qualifiers"/>.  For example, a <el>bvar</el> and a
      <el>condition</el> element can be used to define lists where membership depends on
      satisfying certain conditions.</p>

      <p>An <att>order</att> attribute can be used to specify what ordering is to be
      used. When the nature of the child elements permits, the ordering defaults to a
      numeric or lexicographic ordering.</p>
	
      <p>Sets are structured much the same as lists except that there is no implied
      ordering and the <att>type</att> of set may be <attval>normal</attval> or
      <attval>multiset</attval> with <attval>multiset</attval> indicating that repetitions
      are allowed.</p>
	
      <p>For both sets and lists, the child elements must be valid MathML content
      elements. The type of the child elements is not restricted. For example, one might
      construct a list of equations, or of inequalities.</p>
	
      <p>The child elements of a possibly empty <el>list</el> element are the actual
      components of an ordered <emph>list</emph>. For example, an ordered list of the
      three symbols <var>a</var>, <var>b</var>, and <var>c</var> is encoded as

      <eg role="mathml"><![CDATA[<list><ci>a</ci><ci>b</ci><ci>c</ci></list>]]></eg>
      
      Sets and lists can also be constructed by evaluating a function over a domain of
      application, each evaluation corresponding to a term of the set or list.  In the
      most general form a domain is explicitly specified by a <el>domainofapplication</el>
      element together with optional <el>bvar</el> elements.  Qualifications involving a
      <el>domainofapplication</el> element can be abbreviated in several ways as described
      in <specref ref="contm_qualifiers"/>.  For example, a <el>bvar</el> and a
      <el>condition</el> element can be used to define lists where membership depends on
      satisfying certain conditions.</p>

      <p>An <att>order</att> attribute can be used to specify what ordering is to be
      used. When the nature of the child elements permits, the ordering defaults to a
      numeric or lexicographic ordering.</p>
	
      <p>Sets are structured much the same as lists except that there is no implied
      ordering and the <att>type</att> of set may be <attval>normal</attval> or
      <attval>multiset</attval> with <attval>multiset</attval> indicating that repetitions
      are allowed.</p>
	
      <p>For both sets and lists, the child elements must be valid MathML content
      elements. The type of the child elements is not restricted. For example, one might
      construct a list of equations, or of inequalities.</p>
    </discussion>
    
    <MMLattribute>
      <attname>order</attname>
      <attvalue> lexicographic | numeric </attvalue>
      <attdefault>none</attdefault>
    </MMLattribute>

        <MMLexample><![CDATA[<list><ci>a</ci><ci>b</ci><ci>c</ci></list>]]></MMLexample>
        <MMLexample><![CDATA[<list order="numeric">
  <bvar><ci>x</ci></bvar>
  <condition>
    <apply><lt/><ci>x</ci><cn>5</cn></apply>
  </condition>
</list>
]]></MMLexample>
      </MMLdefinition>
      
  <MMLdefinition id="cds_union" cdrole="application" arity="union">
        <name>union</name>
        
      </MMLdefinition>
      
	  <MMLdefinition id="cds_intersect" cdrole="application" arity="nary">
        <name>intersect</name>
        
      </MMLdefinition>
      
	  <MMLdefinition id="cds_in" cdrole="application" arity="2">
        <name>in</name>
       
      </MMLdefinition>
      
	  <MMLdefinition id="cds_notin" cdrole="application" arity="2">
        <name>notin</name>
      
      </MMLdefinition>
      
	  <MMLdefinition id="cds_subset" cdrole="application" arity="nary">
        <name>subset</name>
        
      </MMLdefinition>
      
	  <MMLdefinition id="cds_prsubset" cdrole="application" arity="nary">
        <name>prsubset</name>
        
      </MMLdefinition>
      
	  <MMLdefinition id="cds_notsubset" cdrole="application" arity="2">
        <name>notsubset</name>
        
      </MMLdefinition>
      
	  <MMLdefinition id="cds_notprsubset" cdrole="application" arity="2">
        <name>notprsubset</name>
        
      </MMLdefinition>
     
      <MMLdefinition id="cds_setdiff" cdrole="application" arity="2">
        <name>setdiff</name>
       
      </MMLdefinition>
      
	  <MMLdefinition id="cds_card" cdrole="application" arity="1">
        <name>card</name>
        <description>
          <p>The card element is the operator element for deriving the size or cardinality
          of a set.  The size of a multset is simply the total number of elements in the
          multiset.</p>
        </description>
	<discussion>
	  <p>The <el>card</el> element is the operator element for the size or cardinality
	  of a set.</p>
	</discussion>
        <MMLexample>
		<description><p>where A is a set with 5 elements.</p>
		</description>
		<![CDATA[<apply><eq/>
  <apply><card/><ci>A</ci></apply>
  <ci>5</ci>
</apply>
]]></MMLexample>
      </MMLdefinition>
      
	  <MMLdefinition id="cds_cartesianproduct" cdrole="application" arity="nary">
        <name>cartesianproduct</name>
        
      </MMLdefinition>
	  
<MMLdefinition id="cds_emptyset"  cdrole="constant">
        <name>emptyset</name>
        
      </MMLdefinition>



</mcd>
