<?xml version="1.0" encoding="utf-8"?>
<!-- $Id: algebra-logic.mcd,v 1.12 2007/11/07 15:53:21 mkohlhas2 Exp $ -->

<mcd xml:id="algebra-logic" version="3.0"
     revision-date="2007-06-27" review-date="2008-06-27">
  <title>Arithmetic Algebra and Logic</title>
 
  <MMLdefinition xml:id="cds_quotient" cdrole="application" arity="2">
    <title>Quotient</title>
    <name>quotient</name>
    <description>
      <p>quotient is the binary function used to represent the operation of integer
	division.  quotient(a,b) denotes q such that a = b*q+r, with |r| less than |b| and
	a*r non-negative. 
      </p>
    </description>
    <discussion>
      <p>The <code>quotient</code> element is the operator used for division modulo a
      particular base. When the <code>quotient</code> operator is applied to integer arguments
      <var>a</var> and <var>b</var>, the result is the <quote>quotient of <var>a</var>
      divided by <var>b</var></quote>. That is, <code>quotient</code> returns the unique
      integer <var>q</var> such that <var>a</var> = <var>q</var> <var>b</var> +
      <var>r</var>. (In common usage, <var>q</var> is called the quotient and <var>r</var>
      is the remainder.)</p>
    </discussion>
    <classification>function</classification>
    <MMLattribute>
      <attname> type </attname>
      <attvalue>MathMLType</attvalue>
      <attdefault> real </attdefault>
    </MMLattribute>
    <rendering>
      <p>There is no commonly used notation for this concept. Some possible renderings are</p> 
      <ul> 
	<li><p>quotient of <var>a</var> divided by <var>b</var></p></li>
	<li><p>integer part of <var>a</var> / <var>b</var></p></li>
	<li><p><graphic role="inline" source="image/f4027.gif" alt="n!"/></p></li>
	<li><p><graphic role="inline" source="image/f4026.gif" alt="\lfloor a/b \rfloor"/></p></li>
      </ul>
    </rendering>
    <optype>binary arithmetic operator</optype>
    <signature> (integer, integer) -> integer </signature>
    <property>
      <description>
	<p>ForAll( [a,b], b != 0, a = b*quotient(a,b) + rem(a,b) )</p>
	</description><![CDATA[<apply><forall/>
  <bvar><ci>a</ci></bvar>
  <bvar><ci>b</ci></bvar>
  <condition><apply><neq/><ci>b</ci><cn>0</cn></apply></condition>
  <apply><eq/>
    <ci>a</ci>
    <apply><plus/>
      <apply><times/>
          <ci>b</ci>
          <apply><quotient/><ci>a</ci><ci>b</ci></apply>
      </apply>
      <apply><rem/><ci>a</ci><ci>b</ci></apply>
    </apply>
  </apply>
</apply>]]></property>
        <MMLexample>
	  <description><p>Various mathematical applications will use this data in
	  different ways. Editing applications might choose an image such as shown below,
	  while a computationally based application would evaluate it to 2
	  when<var>a</var>=13 and <var>b</var>=5.</p>
	  </description>
	  <![CDATA[<apply><quotient/> <ci> a </ci> <ci> b </ci> </apply> ]]>
	</MMLexample>
        <MMLexample><![CDATA[<apply>
  <quotient/>
  <cn>5</cn>
  <cn>4</cn>
</apply>]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_factorial"  cdrole="application" arity="1">
	<title>Factorial</title>
        <name>factorial</name>
        <description>
          <p>This is the unary operator used to construct factorials.  Factorials are
          defined by n! = n*(n-1)* ... * 1</p>
        </description>
	<classification>function</classification>
	<optype>unary arithmetic operator</optype>
        <signature>(algebraic) -> algebraic</signature>
        <signature>(integer) -> integer</signature>
        <property>
          <description>
            <p>ForAll( n, n \gt 0, n! = n*(n-1)! )</p></description><![CDATA[
<apply><forall/>
  <bvar><ci>n</ci></bvar>
  <condition><apply><gt/><ci>n</ci><cn>0</cn></apply></condition>
  <apply><eq/>
    <apply><factorial/><ci>n</ci></apply>
    <apply><times/>
      <ci>n</ci>
      <apply><factorial/>
        <apply><minus/><ci>n</ci><cn>1</cn></apply>
      </apply>
    </apply>
  </apply>
</apply>
]]></property>
        <property>
          <description>
            <p>0! = 1</p></description><![CDATA[
<apply>]]>&lt;eq/&gt;<![CDATA[
  <apply><factorial/><cn>0</cn></apply>
  <cn>1</cn>
</apply>
]]></property>
        <MMLexample>
		 <description><p>If this were evaluated at <var>n</var> = 5 it would evaluate to 120.</p>
		 </description>
		<![CDATA[<apply><factorial/>
  <ci>n</ci>
</apply>]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_divide"  cdrole="application" arity="2">
	<title>Division</title>
        <name>divide</name>
        <description>
          <p>This is the binary MathML operator that is used indicate the mathematical
          operation a "divided by" b.</p>
	</description>
        <classification>function</classification>
        <MMLattribute>
          <attname> type </attname>
          <attvalue>MathMLType</attvalue>
          <attdefault> real </attdefault>
        </MMLattribute>
	<rendering><p>
	  <graphic role = "inline" source = "image/f4028.gif" alt = "a/b"/></p>
	</rendering>
	<optype>binary arithmetic operator</optype>
        <signature> (algebraic, algebraic) -> algebraic </signature>
        <signature> (complex, complex) -> complex </signature>
        <signature> (real, real) -> real </signature>
        <signature> (rational, rational) -> rational </signature>
        <signature> (integer, integer) -> rational </signature>
        <property>
          <description>
            <p>Division by Zero error</p>
          </description><![CDATA[
<apply><forall/>
  <bvar><ci>a</ci></bvar>
  <apply><eq/>
    <apply><divide/><ci> a </ci><cn> 0 </cn>]]><![CDATA[</apply>]]><![CDATA[
    <notanumber/>
  ]]><![CDATA[</apply>]]><![CDATA[
</apply>
]]></property>
        <property>
          <description>
            <p>ForAll( a, a!= 0, a/a = 1 )</p>
          </description><![CDATA[
<apply><forall/>
  <bvar><ci>a</ci></bvar>
  <condition><apply><neq/><ci>a</ci><cn>0</cn></apply></condition>
  <apply><eq/>
    <apply><divide/><ci>a</ci><ci>a</ci></apply>
    <cn>1</cn>
  </apply>
</apply>
]]></property>
	  <MMLexample>
	    <description>
	      <p>As a MathML expression, this does not evaluate. However, on receiving
	      such an expression, some applications may attempt to evaluate and simplify
	      the value. For example, when <var>a</var>=5 and <var>b</var>=2 some
	      mathematical applications may evaluate this to 2.5 while others will treat
	      is as a rational number.</p>
	    </description>
<![CDATA[<apply><divide/>
  <ci> a </ci>
  <ci> b </ci>
</apply>]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_max"  cdrole="application" arity="nary">
	<title>Maximum</title>
        <name>max</name>
        <description>
	  <p>This is the n-ary operator used to represent the maximum of a set of
	  elements. The elements may be listed explicitly or they may be described by a
	  <code>domainofapplication</code>, for example, the maximum over all x in the set A. The
	  <code>domainofapplication</code> is often abbreviated by placing a condition directly on a
	  bound variable.</p>

	<p>The <code>max</code> operator is a n-ary operators may use the domain of
	application qualifiers as described in <specref ref="contm_naryopwithqual"/>.  For
	example, the <code>min</code> and <code>max</code> functions accept a <code>bvar</code> schema
	in cases where the maximum or minimum is being taken over a set of values
	specified by a <code>condition</code> schema together with an expression to be
	evaluated on that set.  In MathML1.0, the <code>bvar</code> element was optional when
	using a <code>condition</code>; if a <code>condition</code> element containing a single
	variable was given by itself following a <code>min</code> or <code>max</code> operator,
	the variable was implicitly assumed to be bound, and the expression to be
	maximized or minimized (if absent) was assumed to be the single bound variable.
	This usage is <intref ref="interf_deprec">deprecated</intref> in MathML 2.0 in
	favor of explicitly stating the bound variable(s) and the expression to be
	maximized or minimized in all cases.</p>

	<p>The <code>min</code> and <code>max</code> elements may also be applied to a list of
	values in which case no qualifier schemata are used.</p>
        </description>
	<classification> function </classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>real</attdefault>
        </MMLattribute>
	<rendering>
	  <ul>
	    <li><p><graphic role="inline" source="image/f4029.gif" alt="\max\{a,b\}"/></p></li>
	    <li><p><graphic role="inline" source="image/f4031.gif" alt="\max\{\,x\in B\land x\notin C\,\}"/></p></li>
	  </ul>
	</rendering>
	<optype>n-ary associative arithmetic operator</optype>
        <signature> (algebraic*) -> algebraic </signature>
        <signature> (domainofapp,function) -> algebraic </signature>
        <signature> (bvar+,domainofapp,algebraic) -> algebraic </signature>
  <!--
        <signature> (bvar,domainofapplication,anything) -> anything        
  <signature> (bvar,lowlimit,uplimit,anything) -> anything </signature>
  -->
        <property>
          <description>
            <p>ForAll( x in S,  max(y in S,y) \geq x )</p>
          </description>
        </property>
        
		<MMLexample>
          <description>
            <p>Maximum of a finite listing of elements</p>
          </description><![CDATA[
<apply><max/><cn>2</cn><cn>3</cn><cn>5</cn></apply>
]]></MMLexample>
        <MMLexample><description>
            <p>Max(y^3,  y in (0,1)) </p>
          </description>
          <![CDATA[
<apply>
  <max/>
  <bvar><ci>y</ci></bvar>
  <condition>
<apply><in/><ci>y</ci><interval><cn>0</cn><cn>1</cn>
</interval></apply>
  </condition>
  <apply><power/><ci> y</ci><cn>3</cn></apply>
</apply>
]]>
		</MMLexample>
		<MMLexample>
		<description><p>When the objects are to be compared explicitly they are listed as arguments to the function as in:</p>
		</description><![CDATA[
		<apply>
		  <max/>
		  <ci> a </ci>
		  <ci> b </ci>
		</apply>
		]]></MMLexample>
		
		<MMLexample>
		  <description>
		    <p>In MathML1.0, the bound variable and expression to be evaluated
		    (<var>x</var>) could be omitted in the example below: this usage is
		    deprecated in MathML2.0 in favor of explicitly stating the bound
		    variable and expression in all cases: </p>
		  </description>
			<![CDATA[
			<apply>
			  <max/>
			  <bvar><ci>x</ci></bvar>
			  <condition>
			    <apply><and/>
			      <apply><in/><ci>x</ci><ci type="set">B</ci></apply>
			      <apply><notin/><ci>x</ci><ci type="set">C</ci></apply>
			    </apply>
			  </condition>
			  <ci>x</ci>
			</apply>
			]]></MMLexample>
		</MMLdefinition>

      <MMLdefinition id="cds_min"  cdrole="application" arity="nary">
	<title>Minimum</title>
        <name>min</name>
        <description>
          <p>This is the n-ary operator used to represent the minimum of a set of
          elements.  The elements may be listed explicitly or they may be described by a
          <code>condition</code>, e.g., the minimum over all x in the set A.</p>
          <p>The elements must all be comparable if the result is to be well defined.</p>

	<p>The <code>min</code> operator is a are n-ary operators may use the domain of
	application qualifiers as described in <specref ref="contm_naryopwithqual"/>.  For
	example, the <code>min</code> and <code>max</code> functions accept a <code>bvar</code> schema
	in cases where the maximum or minimum is being taken over a set of values
	specified by a <code>condition</code> schema together with an expression to be
	evaluated on that set.  In MathML1.0, the <code>bvar</code> element was optional when
	using a <code>condition</code>; if a <code>condition</code> element containing a single
	variable was given by itself following a <code>min</code> or <code>max</code> operator,
	the variable was implicitly assumed to be bound, and the expression to be
	maximized or minimized (if absent) was assumed to be the single bound variable.
	This usage is <intref ref="interf_deprec">deprecated</intref> in MathML 2.0 in
	favor of explicitly stating the bound variable(s) and the expression to be
	maximized or minimized in all cases.</p>

	<p>The <code>min</code> and <code>max</code> elements may also be applied to a list of
	values in which case no qualifier schemata are used.</p>
	</description>
	<discussion>
	  <p>The element <code>min</code> is used to compare the values of its arguments. It
	  returns the minimum of these values respectively.</p>
	</discussion>
        <classification> function </classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>real</attdefault>
        </MMLattribute>
	<rendering>
	  <ul>
	    <li><p><graphic role="inline" source="image/f4030.gif" alt="\min_{x}\{\,x^{2}\mid x\notin B\,\}"/></p></li>
	  </ul>
	</rendering>
	<optype>n-ary associative arithmetic operator</optype>
        <signature> (algebraic*) -> algebraic </signature>
        <signature> (domainofapp,function) -> algebraic </signature>
        <signature> (bvar+,domainofapp,anything) -> algebraic </signature>
        <!-- <signature> (bvar,domainofapplication,anything) -> ordered_set_element        
  <signature> (bvar,lowlimit,uplimit,anything) -> ordered_set_element </signature>
  -->
  <MMLexample>
          <description>
            <p>
Minimum of a finite listing of elements</p>
          </description><![CDATA[
<apply><min/><cn>2</cn><cn>3</cn><cn>5</cn></apply>
]]></MMLexample>
        <MMLexample>
          <description>
            <p>
min(y^2,  y in (0,1)) </p>
          </description><![CDATA[
<apply>
  <min/>
  <bvar><ci>y</ci></bvar>
  <condition>
    <apply><in/><ci>y</ci><interval><cn>0</cn><cn>1</cn></interval></apply>
  </condition>
  <apply><power/><ci> y</ci><cn>2</cn></apply>
</apply>
]]></MMLexample>
		<MMLexample>
		<description>
			<p>The elements to be compared may also be described using bound variables with a <code>condition</code> element and an expression to be minimized, as in:</p>
			<p>Note that the bound variable must be stated even if it might be implicit in conventional notation. </p>
          </description><![CDATA[
		<apply>
		  <min/>
		  <bvar><ci>x</ci></bvar>
		  <condition>
		    <apply><notin/><ci> x </ci><ci type="set"> B </ci></apply>
		  </condition>
		  <apply>
		      <power/>
		    <ci> x </ci>
		    <cn> 2 </cn>
		  </apply>
		</apply>
		]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_minus"  cdrole="application" arity="2">
	<title>Subtraction</title>
        <name>minus</name>
        <description>
          <p>This is the subtraction operator for an additive group. </p>
        </description>
	<discussion>
	  <p>The <code>minus</code> element is the subtraction operator.</p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>real</attdefault>
        </MMLattribute>
	<rendering><p><graphic role="inline" source="image/f4032.gif" alt="x-y"/></p></rendering>
        <signature>(real,real) -> real</signature>
        <signature>(algebraic,algebraic) -> algebraic</signature>
        <signature>[type=MathMLtype](MathMLtype,MathMLtype) -> MathMLtype </signature>
        <property>
          <description>
            <p>ForAll( x, x-x=0 )</p>
          </description><![CDATA[<apply><forall/>
  <bvar><ci> x </ci></bvar>
  <apply><eq/>
    <apply><minus/><ci> x </ci><ci> x </ci></apply>
    <cn>0</cn>
  </apply>
</apply>]]></property>
        <MMLexample>
		<description><p>If this were evaluated at <var>x</var>=5 and 
		<var>y</var>=2 it would yield 3.</p></description>
		<![CDATA[<apply> <minus/>
		  <ci> x </ci>
		  <ci> y </ci>
		</apply>]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_unary_minus"  cdrole="application" arity="1">
	<title>Additive Inversion</title>
        <name>unary_minus</name>
        <description>
          <p>This is the  inversion operator for an additive group. It constructs the additive inverse of
          that group element.</p>
        </description>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>real</attdefault>
        </MMLattribute>
	<rendering><p><graphic role="inline" source="image/f4032.gif" alt="x-y"/></p></rendering>
        <signature>(real) -> real</signature>
        <signature>(algebraic) -> algebraic</signature>
        <signature>[type=MathMLtype](MathMLtype) -> MathMLtype </signature>
        <MMLexample><![CDATA[<apply><minus/><cn>3</cn></apply>]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_plus"  cdrole="application" arity="nary">
	<title>Addition</title>
        <name>plus</name>
        <description>
          <p>This is the n-ary addition operator of an algebraic structure.  Ordinarily,
          the operands are provided explicitly.  As an n-ary operation the operands can
          also be generated by allowing a function or expression vary over a domain of
          application though the sum element is normally used for that purpose.  If no
          operands are provided, the expression represents the additive identity.  If one
          operand, a, is provided the expression evaluates to "a".  If two or more
          operands are provided, the expression represents the (semi) group element
          corresponding to a left associative binary pairing of the operands.  The meaning
          of mixed operand types not covered by the signatures shown here are left up to
          the target system.
	  </p>
	  
          <p>To use different type coercion rules different from those indicated by the
          signatures, use the definitionURL attribute to identify a new definition.</p>
        </description>
	<discussion>
	  <p>The <code>plus</code> element is the addition operator.</p>
	  <p>As an n-ary operator, the operands may in principle also be provided using a
	  domain of application as described in <specref
	  ref="contm_naryopwithqual"/>. However, such expressions can already be
	  represented explicitly using <specref ref="cds_sum"/> so the <code>plus</code>
	  does not normally take qualifiers.</p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>real</attdefault>
        </MMLattribute>
	<rendering><graphic  source="image/f4033.gif" alt="x+y+z"/></rendering>
	<optype>n-ary arithmetic operator</optype>
        <signature>[type=MathMLtype](anything*) -> MathMLtype </signature>
        <signature>(set*) -> set</signature>
        <signature>(multiset*) -> multiset</signature>
        <signature>(algebraic*) -> algebraic</signature>
        <signature>(real*) -> real</signature>
        <signature>(complex*) -> complex</signature>
        <signature>(integer*) -> integer</signature>
        <signature> (domainofapp,function) -> algebraic </signature>
        <signature> (bvar+,domainofapp,algebraic) -> algebraic </signature>
        <property>
          <description>
            <p>an sum of no terms is 0</p>
          </description><![CDATA[
<apply><eq/>
  <apply><plus/></apply>
  <cn>0</cn>
</apply> 
]]></property>
        <property>
          <description>
            <p>a sum of one term is equal to itself</p>
          </description><![CDATA[
<apply><forall/>
  <bvar><ci>a</ci></bvar>
  <apply><eq/>
    <apply><plus/><ci>a</ci></apply>
    <cn>a</cn>
  </apply> 
</apply>
]]></property>
        <property>
          <description>
            <p>Commutativity</p>
          </description><![CDATA[
<apply><forall/>
  <bvar><ci>a</ci></bvar>
  <bvar><ci>b</ci></bvar>
  <condition>
    <apply><and/>
      <apply><in/><ci>a</ci><reals/></apply>
      <apply><in/><ci>b</ci><reals/></apply>
    </apply>
  </condition>
  <apply><eq/>
    <apply><plus/><ci>a</ci><ci>b</ci></apply>
    <apply><plus/><ci>b</ci><ci>a</ci></apply>
  </apply>
</apply>]]></property>
        <MMLexample><![CDATA[<apply><plus/>
  <cn>3</cn>
</apply>]]></MMLexample>
        <MMLexample><![CDATA[<apply><plus/>
  <cn>3</cn>
  <cn>5</cn>
</apply>]]></MMLexample>
       <MMLexample>
	   <description><p>If this were evaluated at <var>x</var> = 5, <var>y</var> = 2 and <var>z</var> = 1 it would yield 8.</p></description>
	   <![CDATA[
			<apply>
			  <plus/>
			  <ci> x </ci>
			  <ci> y </ci>
			  <ci> z </ci>
			</apply>
			]]></MMLexample>
	   
      </MMLdefinition>

      <MMLdefinition id="cds_power"  cdrole="application" arity="2">
	<title>Exponentiation</title>
        <name>power</name>
        <description>
          <p>This is the binary powering operator that is used to construct expressions
          such as a "to the power of" b.  In particular, it is the operation for which a
          "to the power of" 2 is equivalent to a * a.</p>
	</description>
	<discussion>
	  <p>The <code>power</code> element is a generic exponentiation operator. That is,
	  when applied to arguments <var>a</var> and <var>b</var>, it returns the value of
	  <quote><var>a</var> to the power of <var>b</var></quote>.</p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>real</attdefault>
        </MMLattribute>
	<rendering><p>
	  <graphic role="inline" source="image/f4034.gif" alt="x^3"/></p>
	</rendering>
	<optype>binary arithmetic operator</optype>
	<signature> (algebraic, algebraic) -> algebraic </signature>
        <signature> (complex, complex) -> complex </signature>
        <signature> (real, real) -> complex </signature>
        <signature> (rational, integer) -> rational </signature>
        <signature> (integer, integer) -> rational </signature>
        <signature>[type=MathMLtype](anything,anything) -> MathMLtype </signature>
        <property>
          <description>
            <p>ForAll( a, a!=0, a^0=1 )</p>
          </description><![CDATA[
<apply><forall/>
  <bvar><ci>a</ci></bvar>
  <condition><apply><neq/><ci>a</ci><cn>0</cn></apply></condition>
  <apply><eq/>
    <apply><power/><ci>a</ci><cn>0</cn></apply>
    <cn>1</cn>
  </apply>
</apply>
]]></property>
        <property>
          <description>
            <p>ForAll( a, a^1=a )</p>
          </description><![CDATA[
<apply><forall/>
  <bvar><ci>a</ci></bvar>
  <apply><eq/>
    <apply><power/><ci>a</ci><cn>1</cn></apply>
    <ci>a</ci>
  </apply>
</apply>
]]></property>
        <property>
          <description>
            <p>ForAll( a, 1^a=1 )</p>
          </description><![CDATA[
<apply><forall/>
  <bvar><ci>a</ci></bvar>
  <apply><eq/>
    <apply><power/><cn>1</cn><ci>a</ci></apply>
    <cn>1</cn>
  </apply>
</apply>]]></property>
        <MMLexample><![CDATA[<apply><power/><cn>2</cn><ci>x</ci></apply>]]></MMLexample>
        <MMLexample><![CDATA[<apply><power/><ci> x </ci><cn> 3 </cn></apply>]]></MMLexample>
      <MMLexample>
	  <description><p>If this were evaluated at <var>x</var>= 5 it would yield 125.</p></description>
	  <![CDATA[
		<apply>
		  <power/>
		  <ci> x </ci>
		  <cn> 3 </cn>
		</apply>
		]]></MMLexample>
	  </MMLdefinition>

      <MMLdefinition id="cds_rem"  cdrole="application" arity="2">
	<title>Remainder</title>
        <name>rem</name>
        <description>
          <p>This is the binary operator used to represent the integer remainder a mod b.
          For arguments a and b, such that a = b*q + r with |r| &lt; |b| it represents the
          value r.</p>
        </description>
	<discussion>
	  <p>The <code>rem</code> element is the operator that returns the
	  <quote>remainder</quote> of a division modulo a particular base. When the
	  <code>rem</code> operator is applied to integer arguments <var>a</var> and
	  <var>b</var>, the result is the <quote>remainder of <var>a</var> divided by
	  <var>b</var></quote>. That is, <code>rem</code> returns the unique integer,
	  <var>r</var> such that <var>a</var> = <var>q</var> <var>b</var>+ <var>r</var>,
	  where <var>r</var> &lt; <var>q</var>. (In common usage, <var>q</var> is called
	  the quotient and <var>r</var> is the remainder.)</p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>integer</attdefault>
        </MMLattribute>
	<rendering><p>
	  <graphic role = "inline" source = "image/f4035.gif" alt = "a \mod b"/></p>
	</rendering>
	<optype>binary arithmetic operator</optype>
        <signature> (integer, integer) -> integer </signature>
        <signature>[type=MathMLtype](MathMLtype,MathMLtype) -> MathMLtype</signature>
        <property>
          <description>
            <p>rem(a, 0) is undefined</p>
          </description>
        </property>
        <property>
          <description>
            <p>ForAll( [a,b], b!=0, a = b*quotient(a,b) + rem(a,b))</p>
          </description><![CDATA[
<apply><forall/>
  <bvar><ci>a</ci></bvar>
  <bvar><ci>b</ci></bvar>
  <condition><apply><neq/><ci>b</ci><cn>0</cn></apply></condition>
  <apply><eq/>
    <ci>a</ci>
    <apply><plus/>
      <apply><times/>
        <ci>b</ci>
  <apply><quotient/><ci>a</ci><ci>b</ci></apply>
      </apply>
    <apply><rem/>
    <ci>a</ci>
    <ci>b</ci>
  </apply>
</apply>
]]>&lt;/apply&gt;<![CDATA[
</apply>
]]></property>
        <MMLexample>
		<description><p>If this were evaluated at <var>a</var> = 15 and <var>b</var> = 8 it would yield 7.</p>
		</description>
		<![CDATA[<apply><rem/><ci> a </ci><ci> b </ci></apply>]]></MMLexample>
      </MMLdefinition>
      
      <MMLdefinition id="cds_times"  cdrole="application" arity="nary">
	<title>Multiplication</title>
        <name>times</name>
        <description>
	  <p> This is the n-ary multiplication operator of a ring.
	  Ordinarily, the operands are provided explicitly.  As an n-ary operation
	  the operands can also be generated by allowing a function or expression
	  vary over a domain of application though the product element is normally used
	  for that purpose.
	  If no arguments are supplied then this represents the
	  multiplicative identity.  If one argument is supplied, this
	  represents an expression that would evaluate to
	  that single argument.</p>
	</description>
	<discussion>
	  <p>The <code>times</code> element is the n-ary multiplication operator.The operands
	  are usually listed explicitly. As an n-ary operator, the operands may in
	  principle also be provided using a domain of application as described in
	  <specref ref="contm_naryopwithqual"/>.  However, such expressions can already be
	  represented explicitly by using <specref ref="cds_product"/> so the
	  <code>times</code> does not normally take qualifiers.</p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>real</attdefault>
        </MMLattribute>
		<rendering><p>
			<graphic role="inline" source="image/f4036.gif" alt="a b"/></p>
		</rendering>
        <signature> (algebraic*) -> algebraic </signature>
        <signature> (complex*) -> complex </signature>
        <signature> (real*) -> real </signature>
        <signature> (rational*) -> rational </signature>
        <signature> (integer*) -> integer </signature>
        <signature> (domainofapp,function) -> algebraic </signature>
        <signature> (bvar+,domainofapp,anything) -> algebraic </signature>
        <property>
          <description>
            <p>ForAll( [a,b], condition(in({a,b}, Commutative)), a*b=b*a )</p>
          </description>
        </property>
        <property>
          <description>
            <p>ForAll( [a,b,c], Associative, a*(b*c)=(a*b)*c ), associativity </p>
          </description>
        </property>
        <property>
          <description>
            <p>
multiplicative identity</p>
          </description><![CDATA[
<apply><forall/>
  <bvar><ci>a</ci></bvar>
  <apply><eq/>
    <apply><times/><cn>1</cn><ci>a</ci></apply>
    <ci>a</ci>
  </apply> 
</apply>
]]></property>
        <property>
          <description>
            <p> a*0=0 </p>
          </description>
        </property>
        <property>
          <description>
            <p>
Commutative property</p>
          </description><![CDATA[
<apply><forall/>
  <bvar><ci>a</ci></bvar>
  <bvar><ci>b</ci></bvar>
  <condition>
    <apply><and/>
      <apply><in/><ci>a</ci><reals/></apply>
      <apply><in/><ci>b</ci><reals/></apply>
    </apply>
  </condition>
  <apply><eq/>
    <apply><times/><ci>a</ci><ci>b</ci></apply>
    <apply><times/><ci>b</ci><ci>a</ci></apply>
  </apply>
</apply>]]></property>
        <property>
	  <description>
	    <p>a*0=0</p>
	    </description>
	    <![CDATA[<apply><forall/>
  <bvar><ci>a</ci></bvar>
  <apply><eq/>
    <apply><times/><cn>0</cn><ci>a</ci></apply>
    <cn>0</cn>
  </apply> 
</apply>]]>
	</property>

	<MMLexample>
	  <description><p>If this were evaluated at 
	  <var>a</var> = 5.5 and <var>b</var> = 3 it would yield 16.5.</p></description>
	  <![CDATA[<apply><times/><ci>a</ci><ci>b</ci></apply>]]>
	</MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_root"  cdrole="application" arity="2">
	<title>Root</title>
        <name>root</name>
        <description>
          <p>This is the binary operator used to construct the nth root of an expression.
          The first argument "a" is the expression and the second object "n" denotes the
          root, as in ( a ) ^ (1/n)</p>
        </description>
	<discussion>
	  <p>The <code>root</code> element is used to construct roots. The kind of root to be
	  taken is specified by a <quote>degree</quote> child, which should be given as
	  the second child of the <code>apply</code> element enclosing the <code>root</code>
	  element. Thus, square roots correspond to the case where <code>degree</code>
	  contains the value 2, cube roots correspond to 3, and so on.</p>
	  
	  <p>Note that MathML3 supports a <code>degree</code> element in the legacy <intref
	  ref="contm_container">container representation</intref> (see <specref
	  ref="contm_degree"/> for details). If no <code>degree</code> is present, a default
	  value of 2 is used.</p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname> type </attname>
          <attvalue> real | complex | principal_branch | MathMLType </attvalue>
          <attdefault>real</attdefault>
        </MMLattribute>
	<rendering><p>
	  <graphic role = "inline" source = "image/f4037.gif" alt = "\sqrt[n]{a}"/></p>
	</rendering>
	<optype>operator taking qualifiers</optype>
        <signature> (algebraic) -> root(degree(2),algebraic) </signature>
        <signature> (anything) -> root(degree(2),anything) </signature>
        <signature> (degree,anything) -> root </signature>
        <property>
          <description>
            <p>ForAll( bvars(a,n), root(degree(n),a) = a^(1/n) )</p>
          </description><![CDATA[  ]]></property>
        <MMLexample>
          <description>
            <p>The <var>n</var>th root of <var>a</var> is is given by</p>
          </description><![CDATA[<apply><root/>]]>&lt;degree&gt;<![CDATA[<ci> n </ci>]]>&lt;/degree&gt;<![CDATA[<ci> a </ci></apply>]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_gcd"  cdrole="application" arity="nary">
	<title>Greatest Common Divisor</title>
        <name>gcd</name>
        <description>
          <p>This is the n-ary operator used to construct an expression which represents
          the greatest common divisor of its arguments.  If no argument is provided, the
          gcd is 0.  If one argument is provided, the gcd is that argument.</p>
        </description>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>integer</attdefault>
        </MMLattribute>
	<rendering><p>
	  <graphic role="inline" source="image/f4038.gif" alt="\gcd(a, b, c)"/></p>
	  <p>This default rendering is English-language locale specific: other locales 
	  may have different default renderings.</p>
	</rendering>
	<optype>n-ary associative operator</optype>
	<signature> [type=MathMLtype](MathMLtype*) ->MathMLtype </signature>
        <signature>(integer*) -> integer </signature>
        <signature> (domainofapp,function) -> algebraic </signature>
        <signature> (bvar+,domainofapp,algebraic) -> algebraic </signature>
        <property><![CDATA[
<apply><forall/>
]]>&lt;forall/&gt;<![CDATA[  
  <bvar><ci>x</ci></bvar>
  <apply><eq/>
    <apply><gcd/>
      <ci>x</ci>
      <cn>1</cn>
    </apply>
    <cn>1</cn>
  </apply>
</apply>
]]></property>
        <MMLexample><![CDATA[<apply><gcd/>
  <cn>12</cn>
  <cn>17</cn>
</apply>]]></MMLexample>
        <MMLexample><![CDATA[<apply><gcd/>
  <cn>3</cn>
  <cn>5</cn>
  <cn>7</cn>
</apply>]]></MMLexample>
		<MMLexample>
		<description><p>If this were evaluated at <var>a</var> = 15, 
<var>b</var> = 21, <var>c</var> = 48, it would yield 3</p>
		</description>
		<![CDATA[
		<apply> <gcd/>
		  <ci> a </ci>
		  <ci> b </ci>
		  <ci> c </ci>
		</apply>
		]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_and"  cdrole="application" arity="nary">
	<title>Conjunction</title>
        <name>and</name>
        <description>
          <p>This is the n-ary logical "and" operator.  It is used to construct the
          logical expression which were it to be evaluated would have a value of "true"
          when all of its operands have a truth value of "true", and "false"
          otherwise.</p>
        </description>
	<discussion>
	  <p>The <code>and</code> element is the Boolean <quote>and</quote> operator.</p>
	  <p>As an n-ary operator, its operands may also be generated as described
	  in<specref ref="contm_naryopwithqual"/> Therefore it may take qualifiers.</p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>boolean</attdefault>
        </MMLattribute>
	<rendering><p>
	  <graphic role="display" source="image/f4039.gif" alt="a \land b"/></p>
	</rendering>
	<optype>n-ary operator</optype>
        <signature> (boolean*) -> boolean </signature>
        <property>
          <description>
            <p>ForAll( p, (true and p = p) )</p>
          </description><![CDATA[ ]]></property>
        <property>
          <description>
            <p>ForAll( [p,q], (p and q = q and p) ) </p>
          </description>
        </property>
        <property>
          <description>
            <p>x and not(x) = false</p>
          </description>
        </property>
        <MMLexample>
		<description>
            <p>If this were evaluated and both <var>a</var> and 
<var>b</var> had truth values of <attval>true</attval>, then the result would be <attval>true</attval>.</p>
          </description>
		<![CDATA[<apply><and/>
		  <ci>a</ci>
		  <ci>b</ci>
		  </apply>]]>
		</MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_or"  cdrole="application" arity="nary">
	<title>Disjunction</title>
        <name>or</name>
        <description>
          <p>The is the n-ary logical "or" operator.  The constructed expression has a
          truth value of true if at least one of its arguments is true.</p>
        </description>
	<discussion>
	  <p>The <code>or</code> element is the Boolean <quote>or</quote> operator.</p>
	  <p>As an n-ary operator, its operands may also be generated as described
	  in<specref ref="contm_naryopwithqual"/> Therefore it may take qualifiers.</p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>boolean</attdefault>
        </MMLattribute>
	<rendering><p>
	  <graphic role="display" source="image/f4040.gif" alt="a \lor b"/></p>
	</rendering>
	<optype>n-ary operator</optype>
        <signature> (boolean*) -> boolean </signature>
        <signature> [type="boolean"](symbolic*) -> boolean </signature>
        <MMLexample><![CDATA[<apply>
  <or/>
  <ci> a </ci>
  <ci> b </ci>
</apply>
]]></MMLexample>
      </MMLdefinition>
      
      <MMLdefinition id="cds_xor"  cdrole="application" arity="nary">
	<title>Exclusive Disjunction</title>
        <name>xor</name>
        <description>
          <p>The is the n-ary logical "xor" operator.  The constructed expression
has a truth value of true if an odd number of its arguments
are true.</p>
        </description>
	<discussion>
	  <p>As an n-ary operator, its operands may also be generated as described
	  in<specref ref="contm_naryopwithqual"/> Therefore it may take qualifiers.</p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>boolean</attdefault>
        </MMLattribute>
	<rendering>
	  <p><graphic role="inline" source="image/f4041.gif" alt="a \xor b"/></p>
	</rendering>
	<optype>n-ary relation</optype>
        <signature> (boolean*) -> boolean </signature>
        <signature> [type="boolean"](symbolic*) -> symbolic </signature>
        <property>
          <description>
            <p>x xor x = false </p>
          </description>
        </property>
        <property>
          <description>
            <p>x xor not(x) = true </p>
          </description>
        </property>
        <MMLexample><![CDATA[<apply><xor/><ci>a</ci><ci>b</ci></apply>]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_not"  cdrole="application" arity="1">
	<title>Negation</title>
        <name>not</name>
        <description>
          <p>This is the unary logical "not" operator.  It negates the truth value of its
          single argument.  e.g., not P is true when P is false and false when P is
          true.</p>
        </description>
	<discussion>
	  <p>The <code>not</code> operator is the Boolean<quote>not</quote> operator.</p>
	</discussion>
	<classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>boolean</attdefault>
        </MMLattribute>
	<rendering>
	  <graphic role="display" source="image/f4042.gif" alt="\neg a"/>
	</rendering>
	<optype>unary logical operator</optype>
        <signature> (boolean) -> boolean </signature>
        <signature> [type="boolean"](algebraic)  -> boolean </signature>
        <MMLexample><![CDATA[<apply><not/><ci>a</ci></apply>]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_implies"  cdrole="application" arity="2">
	<title>Implication</title>
        <name>implies</name>
        <description>
          <p>This is the binary "implies" operator.  It is used to construct the logical
          expression "A implies B".</p>
        </description>
	<discussion>
	  <p>The <code>implies</code> element is the Boolean relational operator
	  <quote>implies</quote>.</p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>boolean</attdefault>
        </MMLattribute>
	<rendering><p>
	  <graphic role = "display" source = "image/f4043.gif" alt = "A \Rightarrow B"/></p>
	</rendering>
	<optype>binary logical operator</optype>
        <signature> (boolean,boolean) -> boolean </signature>
        <property>
          <description>
            <p>false implies x 
</p>
          </description>
        </property>
        <MMLexample>
		<description>
           <p>Mathematical applications designed for the evaluation of such expressions would evaluate this to <attval>true</attval> when 
<var>a</var> = <attval>false</attval> and <var>b</var> = <attval>true</attval>.</p>
          </description>
		<![CDATA[<apply>
  <implies/>
  <ci> A </ci>
  <ci> B </ci>
</apply>
]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_forall"  cdrole="binder">
	<title>Universal Quantification</title>
        <name>forall</name>
        <description>
          <p>The forall operator is the logical "For all" quantifier.  The bound
          variables, if any, appear first and are tagged using the bvar element.  Next
          comes an optional condition on the bound variables.  The last argument is the
          boolean expression that is asserted to be true for all values of the bound
          variables that meet the specified conditions (if any).</p>
        </description>
	<discussion>
	  <p>The <code>forall</code> element represents the universal quantifier of logic. It
	  is usually used in conjunction with one or more bound variables, an optional
	  <code>condition</code> element, and an assertion. It may also be used with a domain
	  of application and function as described in <specref ref="contm_qualifiers"/> in
	  which case the assertion corresponds to applying the function to an element of
	  the specified domain., which should take the form of an <code>apply</code>
	  element.</p>

	  <p>The universal quantifier <code>forall</code> is used in conjunction with one or
	  more <code>bvar</code> schemata to represent simple logical assertions. There are
	  two main main ways of using the logical quantifier operators. The first usage is
	  for representing a simple, quantified assertion.  For example, the statement
	  <quote>there exists <var>x</var> &lt; 9</quote> would be represented as:

<eg role = "mathml"><![CDATA[<bind>
  <exists/>
  <bvar><ci> x </ci></bvar>
  <apply><lt/><ci>x</ci><cn>9</cn></apply>
</bind>]]></eg>

The second usage is for representing implications. Hypotheses are given by a
<code>condition</code> element following the bound variables. For example the statement
<quote>for all <var>x</var> &lt; 9, <var>x</var> &lt; 10</quote> would be represented as:

<eg role = "mathml"><![CDATA[<bind>
  <forall/>
  <bvar><ci>x</ci></bvar>
  <condition><apply><lt/><ci>x</ci><cn>9</cn></apply></condition>
  <apply><lt/><ci>x</ci><cn>10</cn></apply>
</bind>]]></eg>

Note that in both these usages one or more <code>bvar</code> qualifiers are mandatory.</p>
		</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>boolean</attdefault>
        </MMLattribute>
	<rendering><ul>
	  <li><p><graphic role="inline" source="image/f4044.gif" alt="\forall x: x-x=0"/></p></li>
	  <li><p><graphic role="inline" source="image/f4045.gif" alt="\forall p \in \mathbb{Q}, q \in \mathbb{Q}, p &lt; q: p &lt; q^2"/></p></li>
	  <li><p><graphic role="inline" source="image/f4046.gif" alt="\forall n>0, n \in \mathbb{Z}: \exists x \in \mathbb{Z}, y \in \mathbb{Z}, z \in  \mathbb{Z}: x^n+y^n=z^n"/></p></li></ul>
	  <note><p>The second and third examples in this section are correct MathML expressions of False mathematical statements.</p></note>
	</rendering>
	<optype>quantifier</optype>
	<signature> (domainofapp,function) -> boolean </signature>
        <signature> (bvar+,domainofapp?,boolean) -> boolean </signature>
        <MMLexample>
		<description><p>The example encodes a simple identity.</p>
		</description>
		<![CDATA[<apply>
		  <forall/>
		  <bvar><ci> x </ci></bvar>
		  <apply><eq/>
		    <apply>
		      <minus/><ci> x </ci><ci> x </ci>
		    </apply>
		    <cn>0</cn>
		  </apply>
		</apply>]]></MMLexample>
		<MMLexample>
		<description><p>The example is more involved, and makes use of an optional <code>condition</code> element.</p>
		</description>
		<![CDATA[
		<apply>
		  <forall/>
		  <bvar><ci> p </ci></bvar>
		  <bvar><ci> q </ci></bvar>
		  <condition>
		    <apply><and/>
		      <apply><in/><ci> p </ci><rationals/></apply>
		      <apply><in/><ci> q </ci><rationals/></apply>
		      <apply><lt/><ci> p </ci><ci> q </ci></apply>
		    </apply>
		  </condition>
		  <apply><lt/>
		      <ci> p </ci>
		      <apply>
		          <power/>
		        <ci> q </ci>
		        <cn> 2 </cn>
		      </apply>
		  </apply>
		</apply>
		]]></MMLexample>
		<MMLexample>
		<description><p>The example uses both the <code>forall</code> and
<code>exists</code> quantifiers.</p>
		</description>
		<![CDATA[
		<apply>
		  <forall/>
		  <bvar><ci> n </ci></bvar>
		  <condition>
		    <apply><and/>
		      <apply><gt/><ci> n </ci><cn> 0 </cn></apply>
		      <apply><in/><ci> n </ci><integers/></apply>
		    </apply>
		  </condition>
		  <apply>
		    <exists/>
		    <bvar><ci> x </ci></bvar>
		    <bvar><ci> y </ci></bvar>
		    <bvar><ci> z </ci></bvar>
		    <condition>
		      <apply><and/>
		        <apply><in/><ci> x </ci><integers/></apply>
		        <apply><in/><ci> y </ci><integers/></apply>
		        <apply><in/><ci> z </ci><integers/></apply>
		      </apply>
		    </condition>
		    <apply>
		      <eq/>
		      <apply>
		        <plus/>
		        <apply><power/><ci> x </ci><ci> n </ci></apply>
		        <apply><power/><ci> y </ci><ci> n </ci></apply>
		      </apply>
		      <apply><power/><ci> z </ci><ci> n </ci></apply>
		    </apply>
		  </apply>
		</apply>
		]]></MMLexample>
        <MMLexample><![CDATA[<apply>
		  <forall/>
		  <bvar><ci> x </ci></bvar>
		  <condition><apply><lt/><ci> x </ci><cn> 0
		  </cn></apply></condition>
		  <ci> x </ci>
</apply>
]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_exists" cdrole="binder">
	<title>Existential Quantification</title>
        <name>exists</name>
        <description>
          <p>This is the MathML operator that is used to assert existence, as in "There
          exists an x such that x is real and x is positive."</p>
          <p>- The first argument indicates the bound variable,</p>
          <p>- The second optional argument places conditions on that
bound variable. </p>
          <p>- The last argument is the expression
that is asserted to be true.</p>
        </description>
	<discussion>
	  <p>The <code>exists</code> element represents the existential quantifier of
	  logic. Typically, it is used in conjunction with one or more bound variables, an
	  optional <code>condition</code> element, and an assertion, which may take the form
	  of either an <code>apply</code> or <code>reln</code> element.The <code>exists</code> element
	  may also be used with a general domain of application and function as described
	  in <specref ref="contm_qualifiers"/>.  For such uses the assertion is obtained
	  by applying the function to an element of the specified domain.</p>
	  <p>The universal quantifier <code>forall</code> is used in conjunction with one or
	  more <code>bvar</code> schemata to represent simple logical assertions. There are
	  two main main ways of using the logical quantifier operators. The first usage is
	  for representing a simple, quantified assertion.  For example, the statement
	  <quote>there exists <var>x</var> &lt; 9</quote> would be represented as:

<eg role = "mathml"><![CDATA[<bind>
  <exists/>
  <bvar><ci> x </ci></bvar>
  <apply><lt/><ci>x</ci><cn>9</cn></apply>
</bind>]]></eg>

The second usage is for representing implications. Hypotheses are given by a
<code>condition</code> element following the bound variables. For example the statement
<quote>for all <var>x</var> &lt; 9, <var>x</var> &lt; 10</quote> would be represented as:

<eg role = "mathml"><![CDATA[<bind>
  <forall/>
  <bvar><ci>x</ci></bvar>
  <condition><apply><lt/><ci>x</ci><cn>9</cn></apply></condition>
  <apply><lt/><ci>x</ci><cn>10</cn></apply>
</bind>]]></eg>

Note that in both these usages one or more <code>bvar</code> qualifiers are mandatory.</p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>boolean</attdefault>
        </MMLattribute>
	<rendering>
	  <graphic  source="image/f4047.gif" alt="\exists x: f(x)=0"/>
	</rendering>
	<optype>quantifier</optype>
        <signature> (bvar+,boolean) -> boolean </signature>
        <signature> (bvar+,domainofapp,anything) -> boolean </signature>
        <MMLexample>
		<description><p>The following example encodes the sense of the expression <quote>there exists an <var>x</var> such that <var>f</var>(<var>x</var>) = 0</quote>.</p>
		</description>
		<![CDATA[
		<apply><exists/>
		  <bvar><ci>x</ci></bvar>
		  <apply><eq/>
		    <apply><ci>f</ci>
		      <ci>x</ci>
		    </apply>
		    <cn>0</cn>
		  </apply>
		</apply>
]]></MMLexample>

       <MMLexample><![CDATA[
<apply>
  <exists/>
  <bvar><ci> x </ci></bvar>
  <domainofapplication>
    <ci type="set">C</ci>
  </domainofapplication>
  <apply>
    <eq/>
    <apply>
      <power/><ci>x</ci><cn>2</cn>
    </apply>
    <cn>4</cn>
  </apply>
</apply>
]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_abs"  cdrole="application" arity="1">
	<title>Absolute Value</title>
        <name>abs</name>
        <description>
          <p>A unary operator which represents the absolute value of its argument. 
In the complex case this is often referred to as the modulus. </p>
        </description>
	<discussion>
	  <p>The <code>abs</code> element represents the absolute value of a real quantity or
	  the modulus of a complex quantity.</p>
	</discussion>
	<classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>real</attdefault>
        </MMLattribute>
	<rendering>
	  <p><graphic role="inline" source="image/f4048.gif" alt="|x|"/></p>
	</rendering>
	<optype>unary arithmetic operator</optype>
        <signature>(algebraic) -> algebraic</signature>
        <signature>(real) -> real</signature>
        <signature>(complex) -> real</signature>
        <property>
          <description>
            <p>for all x and y, abs(x) + abs(y) >= abs(x+y) </p>
          </description>
        </property>
        <MMLexample>
		<description><p>The following example encodes the absolute value of <var>x</var>.</p>
		</description>
		<![CDATA[
<apply><abs/><ci>x</ci></apply>
]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_conjugate" cdrole="application" arity="1">
	<title>Complex Conjugate</title>
        <name>conjugate</name>
        <description>
          <p>The unary "conjugate" arithmetic operator is used to represent the complex
          conjugate of its argument.</p>
        </description>
	<discussion>
	  <p>The <code>conjugate</code> element represents the complex conjugate of a complex quantity.</p>
	</discussion>
        <classification>function</classification>
	<rendering>
	  <graphic role="display" source="image/f4049.gif" alt="\overline{x + \ii y}"/>
	</rendering>
	<optype>unary arithmetic operator</optype>
        <signature> (algebraic) -> algebraic </signature>
        <signature>(complex) -> complex</signature>
        <MMLexample>
	  <description>
	    <p>The following example encodes the conjugate of <var>x</var> + i<var>y</var>.</p>
	  </description>
	  <![CDATA[<apply><conjugate/>
 <apply><plus/>
    <ci> x </ci>
    <apply><times/>
      <cn> &ImaginaryI; </cn>
    <ci> y </ci>
    </apply>
  </apply>
</apply>
]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_arg"  cdrole="application" arity="1">
	<title>Argument</title>
        <name>arg</name>
        <description>
          <p>The unary "arg" operator is used to construct 
an  expression which represents the
"argument" of a complex number.</p>
        </description>
	<discussion>
	  <p>The <code>arg</code> operator gives the <quote>argument</quote> of a complex
	  number, which is the angle (in radians) it makes with the positive real
	  axis. Real negative numbers have argument equal to + <graphic role="inline"
	  source="image/f4003.gif" alt="\pi"/>.</p> 
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>real</attdefault>
        </MMLattribute>
	<rendering>
	  <graphic source="image/f4050.gif" alt="\arg(x + \ii y)"/>
	</rendering>
	<optype>unary arithmetic operator</optype>
        <signature>(complex) -> real</signature>
        <MMLexample>
		<description><p>The following example encodes the argument operation on<var>x</var> + i<var>y</var>.</p></description>
		<![CDATA[<apply><arg/>
  <apply><plus/>
    <ci> x </ci>
    <apply><times/><imaginaryi/><ci>y</ci></apply>
  </apply>
</apply>
]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_real"  cdrole="application" arity="1">
	<title>Real Part</title>
        <name>real</name>
        <description>
          <p>A unary operator used to construct an expression
representing the "real" part of a complex number. </p>
        </description>
	<discussion>
	  <p>The <code>real</code> operator (introduced in MathML 2.0) gives the real part of
	  a complex number, that is the x component in <var>x</var> + i <var>y</var></p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>real</attdefault>
        </MMLattribute>
	<rendering>
	  <graphic source="image/f4051.gif" alt="\Re(x + \ii y)"/>
	</rendering>
	<optype>unary arithmetic operator</optype>
        <signature>(complex) -> real</signature>
        <property>
          <description>
            <p>ForAll( [x,y], x in R, Y in R, real(x+i*y)=x) )</p>
          </description><![CDATA[
<apply><forall/>
  <bvar><ci>x</ci></bvar>
  <bvar><ci>y</ci></bvar>
  <condition>
    <apply><and/>
      <apply><in/><ci>x</ci><reals/></apply>
      <apply><in/><ci>y</ci><reals/></apply>
    </apply>
  </condition>
  <apply><eq/>
    <apply><real/>
      <apply><plus/>
        <ci> x </ci>
        <apply><times/><imaginaryi/><ci>y</ci></apply>
      </apply>
    </apply>
    <ci> x </ci>
  </apply>
</apply>
]]></property>
        <MMLexample>
		<description><p>The following example encodes the real operation on<var>x</var> + i<var>y</var>.A MathML-aware evaluation system would return the <var>x</var> component, suitably encoded.</p></description>
		<![CDATA[
<apply><real/>
  <apply><plus/>
    <ci> x </ci>
    <apply><times/><imaginaryi/><ci>y</ci></apply>
  </apply>
</apply>
]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_imaginary"  cdrole="application" arity="1">
	<title>Imaginary Part</title>
        <name>imaginary</name>
        <description>
          <p>The unary function used to construct an expression which represents the
          imaginary part of a complex number.  </p>
        </description>
	<discussion>
	  <p>The <code>imaginary</code> operator (introduced in MathML 2.0)
	  gives the imaginary part of a complex number, that is, the y
	  component in <var>x</var> + i <var>y</var>.</p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>real</attdefault>
        </MMLattribute>
	<rendering>
	  <p><graphic role = "inline" source = "image/new-floor.gif" alt = "\lfloor{a}\rfloor"/></p>
	  <p><graphic source = "image/f4052.gif" alt = "\Im(x + \ii y)"/></p>
	</rendering>
	<optype>unary arithmetic operator</optype>
	<signature>(complex) -> real</signature>
        <property>
          <description>
            <p>ForAll( [x,y], Imaginary(x + i*y) = y )</p>
          </description><![CDATA[
<apply><forall/>
  <bvar><ci type="real"> x </ci></bvar>
  <bvar><ci type="real"> y </ci></bvar>
  <apply><eq/>
    <apply><imaginary/>
      <apply><plus/>
        <ci type="real"> x </ci>
        <apply><times/><imaginaryi/><ci>y</ci></apply>
      </apply>
    </apply>
    <ci type="real"> y </ci>
  </apply>
</apply>
]]></property>
        <MMLexample>
		<description><p>The following example encodes the imaginary operation on <var>x</var> + i<var>y</var>.A MathML-aware evaluation system would return the <var>y</var> component, suitably encoded.</p></description>
		<![CDATA[<apply><imaginary/>
  <apply><plus/>
    <ci> x </ci>
    <apply><times/><imaginaryi/><ci>y</ci></apply>
  </apply>
</apply>
]]></MMLexample>
      </MMLdefinition>
      
      <MMLdefinition id="cds_lcm"  cdrole="application" arity="nary">
	<title>Least Common Multiple</title>
        <name>lcm</name>
        <description>
          <p>This n-ary operator is used to construct an expression 
which represents the least common multiple of its arguments.
If no argument is provided, the lcm is 1.
If one argument is provided, the lcm is that argument.
The least common multiple of x and 1 is x.</p>
        </description>
	<discussion>
	  <p>The 
	  <code>lcm</code> element (introduced in MathML 2.0) is used to denote the lowest common
	  multiple of its arguments.</p>
	  <p>As an n-ary operator, its operands may also be generated as described in
	  <specref ref="contm_naryopwithqual"/> Therefore it may take qualifiers.
	  </p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>integer</attdefault>
        </MMLattribute>
	<rendering><p>
	  <graphic role = "inline" source = "image/new-lcm.gif" alt = "\mathrm{lcm}(a, b, c)"/></p>
	  <p>This default rendering is English-language locale specific: other locales 
	  may have different default renderings.</p>
	</rendering>
	<optype>n-ary operator</optype>
        <signature> [type=MathMLtype](MathMLtype*) -> MathMLtype </signature>
        <signature>(integer*) -> integer</signature>
        <signature>(algebraic*) -> algebraic</signature>
        <signature> (domainofapp,function) -> algebraic </signature>
        <signature> (bvar+,domainofapp,anything) -> algebraic </signature>
        <property>
          <description>
            <p>ForAll( x, lcm(x,1)=x )</p>
          </description><![CDATA[
<apply><forall/>
  <bvar><ci>x</ci></bvar>
  <apply><eq/>
    <apply><lcm/><ci>x</ci><cn>1</cn></apply>
    <ci>x</ci>
  </apply>
</apply>
]]></property>
        <MMLexample><![CDATA[<apply><lcm/>
  <cn>12</cn>
  <cn>17</cn>
</apply>]]></MMLexample>
        <MMLexample><![CDATA[<apply><lcm/>
  <cn>3</cn>
  <cn>5</cn>
  <cn>7</cn>
</apply>]]></MMLexample>
		<MMLexample>
		<description><p>If this were evaluated at <var>a</var> = 2, 
<var>b</var> = 4, <var>c</var> = 6 it would yield 12.</p></description>
		<![CDATA[
		<apply> <lcm/>
		  <ci> a </ci>
		  <ci> b </ci>
		  <ci> c </ci>
		</apply>
		]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_floor"  cdrole="application" arity="1">
	<title>Floor</title>
        <name>floor</name>
        <description>
          <p>The floor element is used to denote the round-down (towards -infinity) operator.</p>
        </description>
	<discussion>
	  <p>The <code>floor</code> element (introduced in MathML 2.0) is used to denote the
	  round-down (towards -infinity) operator.</p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>integer</attdefault>
        </MMLattribute>
	<rendering><p>
	  <graphic role = "inline" source = "image/new-floor.gif" alt = "\lfloor{a}\rfloor"/></p>
	</rendering>
	<optype>unary arithmetic operator</optype>
        <signature> (real) -> integer</signature>
        <signature> [type=MathMLtype](algebraic) -> algebraic</signature>
        <property>
          <description>
            <p>ForAll( x, floor(x) &lt;= x )</p>
          </description><![CDATA[<apply><forall/>
  <bvar><ci>x</ci></bvar>
  <apply><leq/>
    <apply><floor/>
      <ci>x</ci>
    </apply>
    <ci>x</ci>
  </apply>
</apply>]]></property>
        <MMLexample>
		<description><p>If this were evaluated at <var>a</var> = 15.015, it would yield 15.</p>
		</description>
		<![CDATA[<apply> <floor/>
  <ci> a </ci>
</apply>]]></MMLexample>
		<MMLexample><![CDATA[
		<apply> <forall/>
		  <bvar><ci> a </ci></bvar>
		  <apply><and/>
		    <apply><leq/>
		    <apply><floor/>
		    <ci>a</ci>
		    </apply>
		    <ci>a</ci>
		  </apply>    
		    <apply><lt/>
		      <ci>a</ci>
		    <apply><plus/>
		      <apply><floor/>
		      <ci>a</ci>
		    </apply>
		    <cn>1</cn>
		    </apply>
		  </apply>
		  </apply>
		</apply>
		]]></MMLexample>
      </MMLdefinition>

      <MMLdefinition id="cds_ceiling"  cdrole="application" arity="1">
	<title>Ceiling</title>
        <name>ceiling</name>
        <description>
          <p>The ceiling element is used to denote the round-up (towards +infinity) operator.</p>
        </description>
	<discussion>
	  <p>The <code>ceiling</code> element (introduced in MathML 2.0) is used
	  to denote the round-up (towards +infinity) operator.</p>
	</discussion>
        <classification>function</classification>
        <MMLattribute>
          <attname>type</attname>
          <attvalue>MathMLType</attvalue>
          <attdefault>integer</attdefault>
        </MMLattribute>
	<rendering><p>
	  <graphic role = "inline" source = "image/new-ceiling.gif" alt = "\lceil{a}\rceil"/></p>
	</rendering>
	<optype>unary operator</optype>
        <signature> (real) -> integer</signature>
        <signature> [type=MathMLtype](algebraic) -> algebraic</signature>
        <property>
          <description>
            <p>ForAll( x, ceiling(x) &gt;= x )</p>
          </description><![CDATA[<apply><forall/>
  <bvar><ci>x</ci></bvar>
  <apply><geq/>
    <apply><ceiling/>
      <ci>x</ci>
    </apply>
    <ci>x</ci>
  </apply>
</apply>]]></property>
        <MMLexample>
		<description><p>If this were evaluated at <var>a</var> = 15.015, it would yield 16.</p></description>
		<![CDATA[<apply> <ceiling/>
  <ci> a </ci>
</apply>]]></MMLexample>
		<MMLexample><![CDATA[
		<apply> <forall/>
		  <bvar><ci> a </ci></bvar>
		  <apply><and/>
		    <apply><lt/>
		    <apply><minus/>
		      <apply><ceiling/>
		      <ci>a</ci>
		    </apply>
		    <cn>1</cn>
		    </apply>
		      <ci>a</ci>
		  </apply>
		    <apply><leq/>
		    <ci>a</ci>
		    <apply><ceiling/>
		    <ci>a</ci>
		    </apply>
		  </apply>    
		  </apply>
		</apply>
		]]></MMLexample>
      </MMLdefinition>
    </mcd>
